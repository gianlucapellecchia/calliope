backend:
  type: Literal
  opts: [pyomo, gurobi]
  default: pyomo
  doc: Points to the solver interface that will be used on running the model
backend_options:
  type: Dict
  optional: true
bigM:
  type: PositiveFloat
  default: !!float 1e9
  doc: >-
    Used for unmet demand, but should be of a similar order of
    magnitude as the largest cost that the model could achieve. Too
    high and the model will not converge
cyclic_storage:
  type: bool
  default: true
  doc: >-
    If true, storage in the last timestep of the timeseries is
    considered to be the 'previous timestep' in the first timestep
    of the timeseries
ensure_feasibility:
  type: bool
  default: false
mode:
  type: Literal
  opts: [plan, operate]
  default: plan
  doc: >-
    The optimisation mode to use. `plan` optimises investment and
    timeseries decision variables. `operate` fixes investment
    decisions according to user inputs and optimises timeseries
    decision variables using a rolling horizon method
objective:
  type: Literal
  opts: [minmax_cost_optimization]
  default: minmax_cost_optimization
  doc: >-
    Name of internal objective function to use, currently only
    min/max cost-based optimisation is available, which uses the
    objective options `sense` and `cost_class`
objective_options:
  validator: minmax_cost_options
  cost_class:
    type: Dict
    opts: [str, NonNegativeFloat]
    default: {"monetary": 1}
    # TODO: decide on whether to enforce this type check now or to
    # check back with this dictionary only once the data has been
    # loaded (in which case the type would be a Dict)
    doc: >-
      Objective function weights applied to costs in each cost class
  sense:
    type: Literal
    opts: [minimize, maximize]
    default: minimize
    doc: >-
      Set whether to `minimize` or `maximize` the objective function
operation:
  window:
    type: PositiveInt # pandas.Timedelta
    default: 0
    doc: "The time window for the rolling horizon optimisation"
  horizon:
    validator: range_check # horizon >= window
    validator_params: {"min_key": "window" }
    type: PositiveInt # pandas.Timedelta
    default: 0
    doc: >-
      The time horizon of the rolling horizon optimisation, which
      must be less than or equal to the time window
  use_cap_results:
    type: bool
    default: false
    doc: >-
      If true, and loading data from a calliope model saved as
      netCDF, use the results of running the model in `plan` mode to
      set the investment decisions in `operate` mode
solver:
  type: Literal
  opts: [cbc, glpk, gurobi, cplex]
  default: cbc
  doc: "Choice of solver to run from the backend"
solver_io:
  type: str
  optional: true
  doc: >-
    What method the Pyomo backend should use to communicate with
    the solver
solver_options:
  type: Dict
  optional: true
  doc: >-
    Optional configuration for the solvers, using python interface
    notation for the specific solver
spores_options:
  # spatially-explicit, practically optimal results mode
  spores_number:
    type: PositiveInt
    default: 3
    doc: The number of SPORES to generate
  slack:
    type: confloat
    opts: { ge: 0, le: 1 }
    default: 0.1
    doc: >-
      The fraction above the cost-optimal cost to set the maximum cost
      during SPORES
  score_cost_class:
    type: str
    default: spores_score
    doc: The cost class to optimise against when generating SPORES
  objective_cost_class:
    type: Dict
    opts: [str, NonNegativeFloat]
    default: {"spores_score": 1, "monetary": 0}
    doc: >-
      The updated cost class weights used by the objective when running SPORES
  slack_cost_group:
    type: str
    optional: true
    doc: >-
      The group constraint name in which the `cost_max` constraint is
      assigned, for use alongside the slack and cost-optimal cost
  save_per_spore:
    type: bool
    default: false
    doc: >-
      Whether or not to save each SPORE run results separately or as
      one concatenated NetCDF. If True, "save_per_spore_path" or CLI
      argument "--to_netcdf" must be defined (to_netcdf will take
      precendence and be used a the directory name).
  skip_cost_op:
    type: bool
    default: false
    doc: >-
      Whether or not to run the initial cost optimisation model to
      ascertain the cost-optimal cost and initial spores scores. If
      True, will take the group constraint and cost_energy_cap values
      directly.
save_logs:
  type: DirectoryPath
  doc: >-
    Path to directory in which log files will be saved. If given
    as a relative path, it will be relative to the directory of
    the model configuration. Setting this option also turns on
    symbolic solver labels in the Pyomo backend, for easier
    debugging of the logs
zero_threshold:
  type: PositiveFloat
  default: !!float 1e-10
  doc: >-
    Any value coming out of the backend that is smaller than this
    threshold (due to floating point errors, probably) will be set
    to zero
postprocess_options:
  compute_metrics: # TODO: what to call these? metrics? indicators? stats?
    type: bool
    default: true
    doc: >-
      If true, technology capacity factors and levelised costs of
      energy will be computed using the results of the optimisation

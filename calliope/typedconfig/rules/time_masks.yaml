# TODO: list of dictionaries, a list (of abitrary length) of
# dictionaries which can't be validated
- validator: mask_validation
  function:
    type: Literal
    opts: [extreme, extreme_diff]
  options:
    var:
      type: str
      validator: mask_options_var_validation
      doc: |
        Constraint parameter from which timeseries data is
        acquired, e.g. `resource`
    length:
      type: str  # pandas.Timedelta
      doc: "Length of time to mask"
    n:
      type: int
      doc: |
        Number of masks to define TODO: check this is actually the
        case
    padding:
      type: str  # Union[Literal, pandas.Timedelta]
      opts: ['calendar_week']
      doc: "Padding either side of the mask"
    tech:
      type: str
      validator: mask_options_tech_validation
      doc: "tech to select data for from 'var'"
    tech0:
      type: str
      validator: mask_options_tech_validation
      doc: "First tech to select data for from 'var'"
    tech1:
      type: str
      validator: mask_options_tech_validation
      doc: "Second tech to select data for from 'var'"
    how:
      type: Literal
      opts: [min, max]
      doc: |
        Whether to select day masks based on smallest (min)
        value/difference or largest (max) value/difference
    normalize:
      type: bool
      default: true
      doc: |
        Whether or not to normalise the data in 'var' before
        attempting masking
- function:
    type: Literal
    opts: [apply_clustering, resample]
    doc: |
      Function to apply following any masking. TODO: allow this to
      also allow custom functions, not just the above, inbuilt
      options
  function_options:
    validator: function_option_validation
    # TODO: maybe storage_inter_cluster goes here, what's the value,
    # how to be compatible with the other keys?
    clustering_func:
      type: Union[Literal, FileWithSubset]
      opts: ['kmeans', 'hierarchical']
      doc: |
        Method to use for clustering. Can be an algorithm or point
        to a file explicitly providing the cluster number for each
        timestep
    how:
      type: Literal
      opts: [closest, mean]
      doc: |
        Having conducted clustering, how to generate the
        timeseries which is representative of each cluster; either
        'mean' (average of all days in a cluster) or 'closest'
        (day with timeseries closest to the cluster centroid)
    k:
      type: int
      doc: |
        Number of clusters at which to stop kmeans clustering. If
        not given, number of clusters is decided using Hartigan's
        rule
    resolution:
      type: str  # pandas.Timedelta
      doc: "Resolution to which data should be resampled"

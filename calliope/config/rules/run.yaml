backend:
  type: Literal
  opts: [pyomo, gurobi]
  doc: Points to the solver interface that will be used on running the model
# backend_options:
#   # TODO: THIS IS WHERE YOU MERGE IN BACKEND OPTION RULES
#   #validator: backend_validation
solver:
  type: Literal
  opts: [cbc, glpk, gurobi, cplex]
  doc: "Choice of solver to run from the backend"
solver_io:
  type: Text
  doc: |
    What method the Pyomo backend should use to communicate with
    the solver
solver_options:
  type: Dict
  doc: |
    Optional configuration for the solvers, using python interface
    notation for the specific solver
bigM:
  type: PositiveFloat
  default: !!float 1e9
  doc: |
    Used for unmet demand, but should be of a similar order of
    magnitude as the largest cost that the model could achieve. Too
    high and the model will not converge
cyclic_storage:
  type: bool
  default: true
  doc: |
    If true, storage in the last timestep of the timeseries is
    considered to be the 'previous timestep' in the first timestep
    of the timeseries
ensure_feasibility:
  type: bool
mode:
  type: Literal
  opts: [plan, operate]
  default: plan
  doc: |
    The optimisation mode to use. `plan` optimises investment and
    timeseries decision variables. `operate` fixes investment
    decisions according to user inputs and optimises timeseries
    decision variables using a rolling horizon method
objective:
  type: Literal
  opts: [minmax_cost_optimization]
  doc: |
    Name of internal objective function to use, currently only
    min/max cost-based optimisation is available, which uses the
    objective options `sense` and `cost_class`
objective_options:
  # validator: objective_options_validation
  cost_class:
    type: Dict #CostClassDict  # TODO: decide on whether to enforce this type check now or to check back with this dictionary only once the data has been loaded (in which case the type would be a Dict)
    doc: |
      Objective function weights applied to costs in each cost class
  sense:
    type: Literal
    opts: [minimize, maximize]
    doc: |
      Set whether to `minimize` or `maximize` the objective function
operation:
  horizon:
    type: Text # pandas.Timedelta
    doc: |
      The time horizon of the rolling horizon optimisation, which
      must be less than or equal to the time window
  window:
    # validator: range_check # window >= horizon, i.e. the same as [min, max]
    type: Text # pandas.Timedelta
    doc: "The time window for the rolling horizon optimisation"
  use_cap_results:
    type: bool
    doc: |
      If true, and loading data from a calliope model saved as
      netCDF, use the results of running the model in `plan` mode to
      set the investment decisions in `operate` mode
save_logs:
  type: Path
  doc: |
    Path to directory in which log files will be saved. If given
    as a relative path, it will be relative to the directory of
    the model configuration. Setting this option also turns on
    symbolic solver labels in the Pyomo backend, for easier
    debugging of the logs
zero_threshold:
  type: PositiveFloat
  default: !!float 1e-10
  doc: |
    Any value coming out of the backend that is smaller than this
    threshold (due to floating point errors, probably) will be set
    to zero
postprocess_options:
  compute_metrics: # TODO: what to call these? metrics? indicators? stats?
    type: bool
    default: true
    doc: |
      If true, technology capacity factors and levelised costs of
      energy will be computed using the results of the optimisation
